---
title:  "[OS] 컴퓨터 시스템의 구조"

categories:
  - IT
tags:
  - [OS, computer system]
toc: true
toc_sticky: true
---

## 컴퓨터 시스템의 구조

컴퓨터 시스템은 `CPU`, `메모리`, `디스크`, `입출력 장치` 등으로 구성된다.

* CPU

CPU는 내부적으로 크게 3가지로 나눌 수 있다. 연산을 수행하는 산술논리장치(ALU), 제어 명령을 전달하는 컨트롤 장치(CU), 결과 값을 일시적으로 기억하는 레지스터(Register)가 이에 해당된다. 

* Memory

컴퓨터는 정보를 저장해 두었다가 필요할 때 읽어 들여 이용할 수 있는 주 기억 장치가 필요하다. 이 주기억장치에는 컴퓨터가 켜지면 운영체제, 사용자 프로그램등이 메모리공간에 올라가게 된다. CPU는 주기억장치에서 프로그램들의 명령어등을 읽어와 작업을 수행한다. 주 기억창치로는 ROM, RAM 등이 있음.

**프로그램이 수행이 되려면 프로그램이 메모리에 올라가 있어야한다**. 운영체제는 각종 자원들을 관리해야 하기 때문에 부팅이 된 이후로 항상 메모리에 올라가 있어야한다. 운영체제 중에서 항상 메모리에 올라가 있는 부분을 **커널**이라고 한다.

* I/O Device

입출력 장치란, 사용자가 원하는 문자나 그림의 데이터를 컴퓨터로 전달하는 하거나 출력하는 장치이다. 입력장치의 종류에는 키보드, 마우스이 있고 출력 장치로는 모니터, 프린터등이 있다.

![img](https://i.imgur.com/8JAIHTg.png)

## CPU와 IO 연산

컴퓨터에 대한 연산은 CPU가 처리한다. 반면 I/O 디바이스들에 대한 연산은 각각의 **디바이스 컨트롤러**들이 처리한다. 때문에 둘은 서로 동시에 처리가 가능하다. 그리고 각각의 컨트롤러로부터 들어오고 나오는 데이터들은 **로컬 버퍼**에서 관리한다.

데이터가 입출력되었는지는 CPU가 처리하는 게 아니라 각각의 컨트롤러들이 연산을 하고 이것을 CPU에게 인터럽트를 발생시켜 보고하는 형태로 처리된다. CPU는 명령어를 읽어오기 전 인터럽트가 발생하였는지 확인하고 인터럽트가 발생했으면 인터럽트를 먼저 처리하고 그 이후에 명령어를 처리한다.

> **Device Countroller**
>
> 각각의 디바이스들을 I/O연산, 제어관리를 하는 역할을 한다. (각각의 디바이스들의 CPU 역할)
>
> **Device Driver**
>
> 운영체제가 각각의 디바이스를 접근하게 하기위한 인터페이스역할을하는 소프트웨어.
>
> **펌웨어**
>
> 디바이스가 동작하기위한 소프트웨어
>
> **Buffer**
>
> 각각의 디바이스 컨트롤러들이 명령을 내려 디바이스의 데이터를 읽어오거나 출력할때는 데이터를 저장하는 공간이다. (각각의 디바이스들의 램역할)



## 인터럽트

인터럽트는 크게 하드웨어 인터럽트와 소프트웨어 인터럽트가 있다. 하드웨어 인터럽트는 하드웨어가 발생시키고 소프트웨어는 소프트웨어가 인터럽트를 발생시킨다는 차이가 있다. 운영체제는 인터럽트 루틴을 쉽게 찾아가기 위해 인터럽트 벡터를 가지고 있다. 인터럽트 벡터는 인터럽트 종류마다 번호를 정해서, 번호에 따라 처리해야할 코드가 위치한 부분을 포인터로 가리키고 있는 자료구조를 말하며 실제처리는 인터럽트 루틴에서 이루어진다.

* Interrupt

CPU는 I/O 디바이스들이 데이터를 입력할때까지 기다리는게 아니라 자신의 일을 계속 처리하고있게 된다. 이때 I/O 디바이스들에게 입력이 이루어지면 각각의 디바이스 컨틀롤러가 인터럽트를 발생시켜 CPU에게 알려준다. 이때 발생시키는 신호를 인터럽트라고 한다.

* 인터럽트 루틴

운영체제에는 인터럽트가 발생했을 때 각각의 인터럽트에대한 처리가 운영체제 안에 저장되어있다. 이 다양한 인터럽트에대해 각각의 처리해야할 업무들을 정의 해놓은것이 인터럽트 처리 루틴이다.

* 인터럽트 벡터

인터럽트 벡터는 인터럽트 종류마다 번호를 정해서, 번호에 따라 처리해야할 코드가 위치한 부분을 포인터로 가리키고 있는 자료구조를 말한다.

* System Call

응용프로그램이 운영체제의 서비스를 받기위해 커널함수를 호출하는것.

* Timer

특정 프로그램이 무한루프에 빠져 CPU를 독점하는 경우를 막기위해 존재한다. 만약 특정프로그램이 CPU할당시간을 초과한다면 timer는 인터럽트를 발생시켜 CPU의 권한을 운영체제에게 다시 넘긴다.

* mode bit

CPU에서 지금 실행되는 프로그램이 프로그램인지 운영체제인지 구분해주는 역할


## 인터럽트 핸들링

인터럽트는 발생 시 CPU에 의해 운영체제 코드 부분 즉 인터럽트 루틴을 실행한다. 인터럽트가 발생하지 않는다면 CPU는 계속 계속해서 사용자 프로그램의 명령어를 처리한다.

CPU가 사용자 프로그램 처리 중 인터럽트가 발생하면 레지스터의 기존 데이터들이 지워지기 때문에 사용자 프로그램의 현재 수행 중이던 주소 정보를 저장해야 한다.

운영체제 커널 내에는 현재 시스템 내에서 수행되는 프로그램들을 관리하기 위한 자료 구조인 **프로세스 제어 블록(PCB : Process Control Block)** 을 두고 있다. 이 자료 구조 중 일부는 인터럽트가 발생했을 때 프로그램의 어느 부분이 수행되던 중이었는지를 저장하기 위한 자료구조로 사용된다.

이 자료구조를 바탕으로 인터럽트 처리 후 CPU는 다시 원래 프로그램으로 돌아올 수 있다.

## 입출력 구조

### 동기식 입출력

동기식 입출력(synchronous I/O)은 입출력 요청후 입출력 작업이 완료된후에야 CPU의 제어권이 그 프로그램에게 다시 넘어갈 수 있는 방식을 말한다. 따라서 동기식 입출력에서는 입출력 연산이 끝날 때까지 CPU는 아무 일도 수행할 수 없기 때문에 비효율적이다.

따라서 입출력을 수행 중인 프로그램을 **"봉쇄상태(blocked state)"**로 전환하고, CPU를 작업 수행이 가능한 다른 프로그램에 할당한다.

> **동기성 문제**
>
> 만약 A라는 프로그램과 B라는 프로그램이 같은 곳에 입출력 연산을 수행하려고 하고, A가 B보다 먼저 처리될 것을 원하더라도 컨트롤러는 그 순서를 보장하지 않는다. 이러한 문제점을 해결하기 위해서 장치별로 `queue`를 두어 **요청 순서대로 처리**할 수 있도록 한다.



### 비동기식 입출력

비동기식 입출력은 입출력 연산이 끝나기를 기다리는 것이 아니라 cpu의 제어권을 입출력 연산을 호출한 프로그램에게 곧바로 다시 부여하는 방식을 말한다.

![img](https://i.imgur.com/ykkvu39.png)

 동기식 입출력 같은 경우에는 응답이 돌아올 때까지 입출력을 요청했던 프로그램은 봉쇄 상태가 되고 인터럽트가 발생하면 그때 입출력에 관한 프로그램이 봉쇄 상태가 풀리게 되고 CPU를 할당받을 수 있는 상태가 된다.

반면 비동기식 프로그램은 입출력을 요청한 프로세스에게 곧바로 다시 주어지며, 입출력 연산이 완료되는 것과 무관하게 처리 가능한 작업부터 처리한다.

## DMA(Direct Memory Access)

이전에는 메모리에 접근은 cpu에 의해서만 할 수 있었다. 따라서 cpu 이외의 장치가 메모리의 데이터에 접근하기 위해서는 cpu에게 인터럽트를 발생시켜 cpu가 이것을 대신 해주는 방식으로 처리했다.

그런데 모든 메모리 접근 연산이 cpu에 의해서만 이루어질 경우 cpu의 업무가 방해가 되기 때문에 메모리에 접근 가능한 메모리 컨트롤러를 만들었는데 이를 **DMA(Direct Memory Access)**라고 한다.

DMA가 있음으로 더 이상 CPU는 하던 작업을 멈추고 각종 I/O디바이스들의 인터럽트를 처리할 필요없이 DMA Controller에 있는 인터럽트만 처리하면 된다.

## 저장 장치

### 주기억 장치

보통 메모리라고 부르며 전원이 나가면 저장되었던 내용이 모두 사려 저버리는 휘발성(volatile)의 RAM을 매체로 사용하는 경우이다.

### 보조 기억 장치

비휘발성(nonvolatile)의 마그네틱 디스크를 흔히 사용한다. 보조 기억장치는 크게 두가지 부분으로 파일시스템용과 스왑 영역이다.

**파일 시스템**
전원이 나가도 유지해야할 정보가있으면 그것을 파일형태로 보조기억장치에 저장한다.

**스왑 영역**
메인 메모리의 크기는 한정되어있고, 가격이 비싸다. 그러므로 다수의 프로그램이 메인 메모리에 올라가 동시에 수행될경우 메모리 공간이 부족한경우가 많다. 그렇기 때문에 한번에 모두 메인메모리에 올려놓는게 아니라 프로그램이 돌아가기 위한 핵심적인 부분만 메인 메모리에 올려놓고 나머지는 스왑영역에두고 필요할 때마다 메인 메모리로 불러오게 된다.

## 저장 장치의 계층구조

컴퓨터 시스템은 빠른 저장장치부터 느린 저장장치까지 단계적인 **계층구조**로 이루어진다.

빠른 저장 장치는 단위 공간당 가격이 높기때문에 적은 용량을 사용하며, 느린 저장 장치는 가격이 저렴해 대용량을 사용하는 반면 접근속도가 느리다는 약점이 있다.

![img](http://melonicedlatte.com/system/uploads/images/000/001/482/original/image.png?1541583910)

상위 저장 장치로 갈수록 접근 속도가 빠르지만 용량은 적다. 이 때 캐싱 기법을 사용해서 성능을 향상시킨다.

> **캐싱 기법**
>
> 상대적으로 느린 저장장치에 있는 내용중에 당장 사용되거나 빈번히 사용될 정보를 빠른 저장장치에 선별적으로 저장하여, 두 저장 장치 사이의 속도를 완충 시키는 기법을 의미한다.

> **Cashe vs Register**
>
> 캐시와 레지스터의 공통점으로는 '어떤 명령어나 데이터를 저장해두는 저장 공간' 이라는 것이다.
> 차이점은
> 캐시는 **cpu와 별도**로 있는 공간이며, **메인 메모리와 cpu 간의 속도 차이를 극복**하기 위한 것이라는 것이고,
> 레지스터는 **cpu 안에서 연산을 처리하기 위하여 데이터를 저장하는 공간** 이라는 것이다. 



## 하드웨어 보안

일반적으로 운영체제는 여러 프로그램이 동시에 실행될 수 있는 다중 프로그래밍 환경에서 실행되므로, 프로그램 간 서로 충돌이 이러날 수 있다. 이러한 문제를 해결하기 위한 보안 기법이 필요하다.

- **커널모드**

  커널모드는 운영체제가 cpu 제어권을 가지고 운영체제의 코드를 실행하는 모드이다.

- **사용자모드**

  사용자 모드는 일반 사용자 프로그램이 실행되면서 제한적인 명령만 수행할 수 있는 모드이다.

컴퓨터 시스템은 **cpu 내부에 mode bit를 두어 사용자 프로그램을 감시한다.** mode bit가 0으로 세팅되어 있으면 커널모드로 모든 명령을 수행할 수 있고, 1이면 사용자 모드로 제한된 명령만 수행한다. CPU보안과 관련된 명령을 수행하기 전에는 mode bit를 조사해 0으로 세팅된 경우에만 명령을 수행한다.

만약 프로그램이 실행되다가 하드웨어 접근 등 보안이 필요한 명령을 수행할 경우에 시스템 콜을 통해 운영체제에게 명령 수행을 의뢰한다. 그러면 mode bit이 0이 되어 명령을 실행한 뒤에 mode bit을 다시 1로 바꾼 후 사용자 프로그램에게 cpu를 다시 할당해준다.

## 메모리 보안

여러 프로그램이 메모리에 올라가 있고 다른 프로그램의 메모리에 침범할 수 있기 때문에 두 개의 레지스터를 사용해서 프로그램이 접근하려는 메모리가 적절한지를 판단한다.

이 때 사용되는 두 개의 레지스터는 **기준 레지스터(base register)**와 **한계 레지스터(limit register)**이다.

기준 레지스터는 실행되고 있는 프로그램이 합법적으로 접근이 시작되는 메모리 주소를 보관하고 있고, 한계 레지스터는 해당 프로그램이 기준 레지스터로부터 접근할 수 있는 범위를 저장하고 있다. 사용자 프로그램은 이 두 개의 값의 범위만 접근할 수 있고 이 범위를 벗어난 접근을 하게 되면 예외 인터럽트가 발생하게 된다.

## cpu 보안

특정 프로그램이 cpu를 독점하고 있는 상태가 발생하는 것을 막기 위해서 운영체제는 **timer**를 실행시키고 일정 시간이 지나면 인터럽트를 발생시켜 운영체제가 제어권을 획득하도록 한다. 운영체제는 다른 프로그램에게 cpu를 할당한다.



출처 

[book] 운영체제와 정보기술의 원리
[https://wan-blog.tistory.com/32](https://wan-blog.tistory.com/32)