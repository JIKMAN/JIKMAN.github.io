---
title:  "[OS] CPU 스케줄링"

categories:
  - IT
tags:
  - [OS, scheduling]
toc: true
toc_sticky: true
---

## CPU 스케줄링

CPU 스케줄러는 프로세스가 생성된 후 종료될 때까지 모든 상태 변화를 조정하는 일을 한다. 이 스케줄러가 하는 CPU 스케줄링은 어떤 프로세스에 CPU를 배정할지 결정하고, 이 작업은 컴퓨터 시스템의 효율에 직결되는 중요한 일이다.

CPU 스케줄링의 본 목적은 모든 프로세스가 공평하게 작업할 수 있도록 하는 것이다. 하지만 안정성과 효율성을 높이기 위해 공평성의 일부분을 희생해야 한다. 다음은 스케줄링이 추구하는 목적들이다.

 

1. **공평성** : 모든 프로세스가 자원을 공평하게 배정받아야 하며, 특정 프로세스가 배제되어서는 안 된다.

2. **효율성** : 시스템 자원을 놀리는 시간 없이 스케줄링해야 한다.

3. **안정성** : 우선순위를 사용하여 중요한 프로세스가 먼저 처리되도록 해야 한다.

4. **반응 시간 보장** : 응답이 없는 경우 사용자는 시스템이 멈춘 것으로 가정하기 때문에 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야 한다.

5. **무한 연기 방지** : 특정 프로세스의 작업이 무한히 연기되어서는 안 된다.



* **고수준 스케줄링(long-term scheduling, job scheduling, admissin scheduling)**

가장 큰 틀에서 이루어지는 CPU 스케줄링으로 시스템 내의 전체 작업 수를 조절한다. 시스템 과부하를 막기 위해 어떤 작업을 시스템이 받아들일지 또는 거부할지를 결정하므로 시스템 내에서 동작 시에 실행 가능한 프로세스의 총개수가 정해진다.

* **중간 수준 스케줄링**

중지(suspend)와 활성화(active)로 전체 시스템의 활성화된 프로세스 수를 조절한다. 이로 인해 저수준 스케줄링이 원만하게 이루어지도록 완충하는 역할을 한다.

* **저수준 스케줄링(short-term scheduling)** 

가장 작은 단위의 스케줄링으로 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정하는 역할이다. 중간 수준의 스케줄링은 프로세스를 보류 상태로 보내고, 저수준 스케줄링은 대기 상태로 보낸다. 스케줄링에 대해 공부하는 대부분의 내용이 이 저수준 스케줄링에 해당한다.



> ### 선점형 스케줄링 vs 비선점형 스케줄링


**선점형 스케줄링** : 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 방식

CPU 처리 시간이 매우 긴 프로세스가 CPU 사용 독점을 막을 수 있어 효율적인 운영이 가능하지만 잦은 문맥 교환(Context Switch)으로 오버헤드가 많이 발생한다.

**비선점형 스케줄링** : 프로세스가 CPU를 점유하고 있다면 이를 빼앗을 수 없는 방식

필요한 문맥 교환만 일어나기 때문에 오버헤드가 상대적으로 적지만 프로세스의 배치에 따라 효율성 차이가 많이 난다.

> ### 전면 프로세스 vs 후면 프로세스


**전면 프로세스** : GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓여 현재 입출력이 사용되고, 사용자와 상호작용이 가능해 상호작용 프로세스라고도 불림 (워드 프로세스)

**후면 프로세스** : 사용자의 입력 없이 작동하여 일괄 작업 프로세스라고 불림 (압축 프로세스)

전면 프로세스는 사용자의 요구에 즉각 즉각 반응해야 하지만 후면 프로세스는 그럴 필요가 없다. 따라서 전면 프로세스를 먼저 처리해 줘야 한다.



## 스케줄링 알고리즘

> ### 성능 척도

**CPU utilization(CPU 사용률)**

시스템의 동작 시간 중 CPU가 사용된 시간을 측정하는 방법으로 최대한 CPU를 바쁘게 만드는 것이다. 가장 이상적인 수치는 물론 100%다.

**Throughput(처리량)**

단위 시간당 작업을 마친 프로세스의 수다. 즉, CPU 버스트를 처리한 수다. 

**Trun-around time(반환 시간)**

프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간이다. 프로세스의 대기 시간 + 실행시간이다. 여기서 대기 시간은 없을 수도 있고, 1번일 수도, 여러 번일수도 있다.

**Waiting time(대기 시간)**

프로세스가 CPU를 할당받아 실행되기 전 대기 상태일 때의 시간이다. 보통 준비 큐에서 대기를 하는 시간이다.

**Response time(응답 시간)**

프로세스가 대기 상태에 들어와 CPU를 최초로 얻기까지 걸리는 시간이다. 대기 시간과의 차이점은 대기 시간은 반환 시간과 마찬가지로 여러 번 있을 수 있다. 그 총합이 대기 시간이고, 응답 시간은 최초의 한 번이다. 이 응답 시간은 프로세스 입장에서 CPU를 한 번도 못 얻은 것과 한 번이라도 얻는 것은 사용자 응답에 있어서 중요한 차이가 있기 때문에 중요하다.



> ### 알고리즘

#### **FCFS (First Come First Served)**

말 그대로 **선입선출** 방식으로, 준비 큐에 도착한 순서대로 CPU를 할당하는 **비선점형** 방식이다. 모든 프로세스의 우선순위가 동일하고, 프로세스의 CPU 처리 시간을 따로 고려하지 않기 때문에 매우 단순하고 공평한 방법이다. 

하지만 CPU 처리 시간이 긴 프로세스가 앞에 올 경우 뒤의 프로세스가 한없이 기다려야 하기 때문에 비효율적이게 된다. 이를 **콘보이 효과**라고 한다.

![img](https://blog.kakaocdn.net/dn/dufF6d/btqtWhgy7Zl/BMv2BKEl9fSAF3GxFKIwjk/img.png)ㅏ

#### **SJF (Shortest Job First)**

준비 큐에 있는 프로세스 중 **실행 시간이 가장 짧은 작업부터** CPU를 할당하는 **비선점형** 방식이다. 늦게 도착하더라도 CPU 처리 시간이 앞에 대기중인 프로세스보다 짧으면 먼저 CPU를 할당받을 수 있다. 때문에 콘보이 효과를 완화할 수 있다.

단, 비선점형 방식이기 때문에 CPU를 사용중인 프로세스보다 처리 시간이 짧더라도 빼앗지는 못한다.

![img](https://blog.kakaocdn.net/dn/bzYkhC/btqtY8oiA3Q/4kZqk2gBuwj0klLXZzVUN0/img.png)

#### **HRN(Highest Response Ratio Next)**

SJF 스케줄링에 **Aging** 기법을 합친 비선점형 알고리즘이다.
SJF와 마찬가지로 실행 시간이 적은 프로세스의 우선 순위가 높지만 대기 시간이 너무 길어지면 실행 시간이 길더라도 CPU를 할당받을 수 있다.

❓  **Aging**이란 나이를 먹는다는 의미 그대로 starvation을 해결하기 위해 대기 시간이 길어지면 우선순위를 높여주는 방법이다.



 ❓  **starvation**는 프로세스가 끊임없이 필요한 컴퓨터 자원을 가져오지 못하는 상황을 말한다.



#### **SRTF (Shortest Remaning Time First)**

SJF의 **선점형 방식**이다. 먼저 온 프로세스가 CPU를 할당받고 있더라도 남은 처리 시간이 뒤에 온 프로세스의 처리 시간보다 길면 CPU를 빼앗긴다.

어떤 알고리즘보다 **평균 대기 시간이 가장 짧은 알고리즘**이다.

하지만 이 방식은 기본적으로 선점형 방식이기 때문에 잦은 문맥교환이 일어나고 그에 따른 오버헤드가 커진다. 그리고 **starvation 현상이 더 심각하게 발생**할 수 있다.

또한 CPU의 예상 시간을 예측하기가 너무 힘들기 때문에 실제로 사용되기가 매우 어렵다. (exponential averaging을 통해 예측을 할 수는 있다.)

![img](https://blog.kakaocdn.net/dn/ceeNYb/btqtYLAlP1i/J1q8Bp7y8qorIE4d7yttQk/img.png)

#### **Priority Scheduling**

CPU를 가장 높은 우선순위를 가진 프로세스에 할당하는 방법이다.

우선순위 스케줄링의 주요 문제는 **무한 봉쇄(indefinite blocking)** 또는 **기아 상태(startvation)** 이다. 높은 우선순위의 프로세스가 계속 들어올 경우, 낮은 우선순위 프로세스들이 CPU를 무한히 대기하는 경우가 발생할 수 있다.

starvation 문제에 대한 한 가지 해결 방안은 **aging** 이다. 오랫동안 시스템에서 대기한는 프로세스들의 우선순위를 점진적으로 증가시키는 방법이다.



#### **RR(Round Robin)**

프로세스에게 각각 **동일한 CPU 할당 시간**(타임 슬라이스, quantum)을 부여해서 이 시간 동안만 CPU를 이용하게 한다. 만약 할당 시간동안 처리를 다 하지 못하면 CPU를 빼앗고 다음 프로세스에게 넘긴다. 빼앗긴 프로세스는 준비 큐의 맨 뒤로 간다. 따라서 **선점형 방식**이다.

따로 CPU 처리 시간을 계산하지 않아도 돼서 선점형 방식의 가장 단순하고 대표적인 방법이다. 우선 순위도 없기 때문에 매우 공평하다.

라운드 로빈 알고리즘의 경우, 만약 할당 시간이 q고 대기 중인 프로세스가 n개라면 어떤 프로세스도 (n-1)q 이상을 기다리지 않아도 된다. 이는 곧 **모든 프로세스가 최초 응답 시간을 빠르게 보장받을 수 있다**는 큰 장점을 가지게 된다. 자연히 콘베이 효과 역시 줄어든다.

![img](https://blog.kakaocdn.net/dn/bwsAyu/btqtYKVKWZO/zr8z1dwh0dcHjioiwhUMIK/img.png)

위의 그림은 **time quantum**(타임 슬라이스)이 5인 경우이다.

라운드 로빈 방식에서 가장 중요한 부분은 타임 슬라이스의 크기 결정이다.

**타임 슬라이스가 큰 경우** 처리 시간이 긴 프로세스에 의해 CPU의 효율성이 떨어질 수 있다. 비디오 플레이어와 워드 프로세서를 동시에 실행했을 때 타임 슬라이스가 크다면 비디오가 약간 씩 끊겨서 재생될 것이다. 그리고 만약 타임 슬라이스가 무한대로 설정되면 FCFS 스케줄링과 다를 바 없어진다. 

**타임 슬라이스가 작은 경우** 여러 프로그램이 동시에 실행되는 효과를 볼 수 있다. 하지만 너무 작으면 잦은 context switch로 인해 오버헤드가 상당히 커진다.

때문에 적당한 타임 슬라이스를 설정하는 것이 중요하다. 보통 10-100 ms로 설정한다.



#### **Multilevel Queue**

다단계 큐 스케줄링은 **우선순위**에 따라 준비 **큐를 여러 개 사용**하는 방식이다. 당연히 우선순위가 높은 큐에 먼저 CPU가 할당되어 큐에 속한 모든 프로세스가 처리되야 다음 우선순위 큐가 실행될 수 있다. 그리고 한 번 우선순위가 매겨저 준비 큐에 들어가면 이 우선순위는 바뀌지 않는다.



![img](https://blog.kakaocdn.net/dn/LqYAc/btqtW0lcMXw/kM2ex6H9lu5f2tSfjoRgvK/img.png)

각 큐는 독립적인 스케줄링 알고리즘을 가질 수 있는데, 보통 전면 프로세스들이 속해있는 큐는 우선순위고 높고 라운드 로빈 스케줄링을 사용해 타임 슬라이스를 작게한다.

후면 프로세스에는 사용자와의 상호작용이 없으므로 가장 간단한 FCFS 방식으로 처리한다. 보통 총 CPU 시간이 전면 프로세스의 처리에 80%, 후면 프로세스 처리에 20%가 할당된다.

이 다단계 큐 알고리즘 역시 문제는 starvation 현상과 공평성 문제다.



#### **Multilevel Feedback Queue**

다단계 큐의 공평성 문제를 완화하기 위해 신분 하락이 가능한 알고리즘이다. 이 알고리즘에서는 우선순위가 변동되기 때문에 큐 사이의 이동이 가능하다.

한 번 CPU를 할당받은 프로세스는 우선순위가 조금 낮아진다. 따라서 더 낮은 큐로 이동하게 된다. (우선순위가 높아져 상위 큐로 **Aging**할 수도 있다.)

그리고 더 보완하기 위해 우선순위가 높은 큐보다 우선순위가 낮은 큐에 타임 슬라이스 크기를 크게 준다. 어렵게 얻은 CPU를 좀 더 오랫동안 사용하게 해주기 위함이다.



![img](https://blog.kakaocdn.net/dn/bt1O9K/btqtWHGcTpB/3OHZNOKR4XRoBV8njb5Gjk/img.png)